<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pyramid Card Game - Multiplayer</title>
  <style>
    body {
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      color: white;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .screen {
      display: none;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 600px;
    }

    .active {
      display: flex;
    }

    select, button, input[type="text"] {
      font-size: 1rem;
      padding: 10px;
      margin: 10px;
      border-radius: 6px;
      border: none;
    }

    input[type="text"] {
      border: 1px solid #ccc;
      width: 200px;
    }

    button {
      background-color: #f1c40f;
      font-weight: bold;
      cursor: pointer;
      min-width: 120px;
    }

    button:disabled {
      background-color: #666;
      cursor: not-allowed;
    }

    .connection-info {
      background: rgba(52, 152, 219, 0.2);
      border: 1px solid #3498db;
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      text-align: center;
    }

    .game-code {
      font-size: 1.5rem;
      font-weight: bold;
      color: #f1c40f;
      margin: 10px 0;
      letter-spacing: 3px;
    }

    .players-list {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      min-height: 100px;
    }

    .player-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
    }

    .player-item.is-host {
      border: 2px solid #f1c40f;
    }

    .player-item.is-you {
      border: 2px solid #3498db;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #27ae60;
    }

    #table {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 100px auto 0;
      border-radius: 50%;
      background: #228B22;
    }

    .pyramid {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .row {
      display: flex;
      justify-content: center;
      margin: 4px 0;
    }

    .player {
      position: absolute;
      display: flex;
      flex-direction: column;
      gap: 2px;
      cursor: pointer;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px dashed white;
      width: 140px;
      padding: 8px;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 0.8rem;
      border-radius: 8px;
    }

    .player.current-user {
      background-color: rgba(52, 152, 219, 0.3);
      border: 2px solid #3498db;
    }

    .player.is-host {
      border-color: #f1c40f;
    }

    .player-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 5px;
    }

    .player-name {
      font-size: 0.85rem;
      font-weight: bold;
      white-space: nowrap;
      margin-bottom: 3px;
    }

    .drink-counter {
      background: rgba(220, 53, 69, 0.8);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: bold;
      min-width: 20px;
      text-align: center;
    }

    .player-cards {
      display: flex;
      gap: 2px;
      flex-wrap: nowrap;
      justify-content: center;
      margin-bottom: 5px;
    }

    .player-actions {
      display: flex;
      gap: 3px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .action-btn {
      padding: 3px 6px;
      font-size: 0.65rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }

    .target-btn {
      background-color: #28a745;
      color: white;
    }

    .card {
      width: 25px;
      height: 40px;
      perspective: 600px;
    }

    .card-inner {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.6s;
    }

    .card.flipped .card-inner {
      transform: rotateY(180deg);
    }

    .card-front, .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 4px;
      border: 1px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 0.7rem;
    }

    .card-back {
      background: navy;
      color: white;
    }

    .card-front {
      background: white;
      color: black;
      transform: rotateY(180deg);
    }

    .pyramid .card {
      width: 30px;
      height: 50px;
    }

    .pyramid .card-front, .pyramid .card-back {
      font-size: 1.1rem;
    }

    #game-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 0.9rem;
      max-width: 250px;
    }

    #current-turn {
      background: rgba(52, 152, 219, 0.8);
      padding: 5px 10px;
      border-radius: 6px;
      margin-bottom: 10px;
      text-align: center;
      font-weight: bold;
    }

    .phase-actions {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .phase-actions button {
      padding: 8px 12px;
      font-size: 0.8rem;
      margin: 2px;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: #2c2c2c;
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .modal-buttons button {
      padding: 10px 20px;
      font-size: 1rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }

    .accept-btn {
      background-color: #dc3545;
      color: white;
    }

    .challenge-btn {
      background-color: #ffc107;
      color: black;
    }

    .target-player-btn {
      background-color: #28a745;
      color: white;
      margin: 5px;
      min-width: 120px;
    }

    .cancel-btn {
      background-color: #6c757d;
      color: white;
    }

    .game-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px 30px;
      border-radius: 10px;
      font-size: 1.2rem;
      font-weight: bold;
      z-index: 1500;
      text-align: center;
      max-width: 400px;
      border: 2px solid #f1c40f;
      display: none;
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -60%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }

    .connection-status {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-size: 0.9rem;
    }

    .connection-status.connected {
      border: 2px solid #27ae60;
    }

    .connection-status.disconnected {
      border: 2px solid #e74c3c;
    }

    .recall-phase {
      background: rgba(156, 39, 176, 0.8);
    }
  </style>
</head>
<body>
  <!-- Menu Screen -->
  <div id="menu-screen" class="screen active">
    <h1>üÉè Pyramid Card Game</h1>
    <h2>Choose Game Mode</h2>
    
    <button onclick="showHostScreen()">Host New Game</button>
    <button onclick="showJoinScreen()">Join Game</button>
  </div>

  <!-- Host Screen -->
  <div id="host-screen" class="screen">
    <h1>üÉè Host New Game</h1>
    
    <label for="host-name">Your Name:</label>
    <input type="text" id="host-name" placeholder="Enter your name" value="Host Player">
    
    <button onclick="hostGame()" id="host-btn">Create Game</button>
    <button onclick="showMenuScreen()">Back</button>

    <div id="host-info" style="display:none;">
      <div class="connection-info">
        <h3>Game Created!</h3>
        <p>Share this code with other players:</p>
        <div class="game-code" id="host-game-code">LOADING...</div>
        <p>Players can join at: <strong>your-game-url.com</strong></p>
      </div>

      <div class="players-list">
        <h4>Players in Game:</h4>
        <div id="host-players-list"></div>
      </div>

      <button onclick="startHostedGame()" id="start-game-btn" disabled>Start Game (Need 2+ players)</button>
    </div>
  </div>

  <!-- Join Screen -->
  <div id="join-screen" class="screen">
    <h1>üÉè Join Game</h1>
    
    <label for="join-name">Your Name:</label>
    <input type="text" id="join-name" placeholder="Enter your name" value="Player">
    
    <label for="game-code-input">Game Code:</label>
    <input type="text" id="game-code-input" placeholder="Enter game code" style="text-transform:uppercase;">
    
    <button onclick="joinGame()" id="join-btn">Join Game</button>
    <button onclick="showMenuScreen()">Back</button>

    <div id="join-info" style="display:none;">
      <div class="connection-info">
        <h3>Joined Game!</h3>
        <div class="game-code" id="join-game-code">GAME123</div>
        <p>Waiting for host to start the game...</p>
      </div>

      <div class="players-list">
        <h4>Players in Game:</h4>
        <div id="join-players-list"></div>
      </div>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen">
    <h1>Pyramid Drinking Game</h1>
    
    <div id="game-controls">
      <div id="current-turn">Setting Up...</div>
      <div id="phase-display">Phase: Setup</div>
      <div id="timer-display" style="display:none;">Time: <span id="countdown">30</span>s</div>
      <div id="current-card-display" style="display:none;">Current Card: <span id="current-card"></span></div>
      <div class="phase-actions">
        <button onclick="autoStart()" id="auto-start-btn" style="display:none;">Auto Deal & Start</button>
        <button onclick="startMemorizePhase()" id="memorize-btn" style="background-color:#e74c3c;color:white;display:none;">Start Memorizing (30s)</button>
        <button onclick="nextPyramidCard()" id="pyramid-btn" style="background-color:#3498db;color:white;display:none;">Flip Next Card</button>
        <button onclick="startRecallPhase()" id="recall-btn" style="background-color:#9c27b0;color:white;display:none;">Start Recall Phase</button>
      </div>
    </div>

    <div id="table" class="table">
      <div id="pyramid" class="pyramid"></div>
    </div>

    <div id="connection-status" class="connection-status disconnected">
      Connecting...
    </div>
  </div>

  <!-- Target Selection Modal -->
  <div id="target-modal" class="modal">
    <div class="modal-content">
      <h3 id="target-message">Choose who to make drink:</h3>
      <div id="target-buttons" class="modal-buttons"></div>
    </div>
  </div>

  <!-- Bluff Modal -->
  <div id="bluff-modal" class="modal">
    <div class="modal-content">
      <h3 id="bluff-message">Player X wants you to drink!</h3>
      <p>You can either drink or call their bluff.</p>
      <div class="modal-buttons">
        <button class="accept-btn" onclick="acceptDrink()">Take the Drink</button>
        <button class="challenge-btn" onclick="callBluff()">Call Bluff!</button>
      </div>
    </div>
  </div>

  <!-- Game Message Display -->
  <div id="game-message" class="game-message"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
  <script>
    // Game state
    const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    let socket = null;
    let gameCode = null;
    let playerId = null;
    let isHost = false;
    let gameState = {};
    let connectedPlayers = {};
    
    // Game variables
    let deck = [];
    let players = [];
    let flipIndex = 0;
    const playerHands = {};
    const drinkCounts = {};
    let playerNames = [];
    let gamePhase = 'setup';
    let currentPyramidCard = null;
    let memorizeTimer = null;
    let timeLeft = 30;
    let currentChallenger = null;
    let currentTarget = null;
    let currentRecallPlayer = 0;
    let myPlayerId = null;

    // Initialize socket connection
    function initSocket() {
      // Auto-detect environment and connect appropriately
      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      const socketUrl = isLocal ? 'ws://localhost:3000' : undefined; // undefined means same origin
      
      socket = io(socketUrl);
      
      socket.on('connect', () => {
        updateConnectionStatus(true);
      });

      socket.on('disconnect', () => {
        updateConnectionStatus(false);
      });

      socket.on('gameCreated', (data) => {
        gameCode = data.gameCode;
        playerId = data.playerId;
        isHost = true;
        document.getElementById('host-game-code').textContent = gameCode;
        document.getElementById('host-info').style.display = 'block';
        updatePlayersList();
      });

      socket.on('gameJoined', (data) => {
        gameCode = data.gameCode;
        playerId = data.playerId;
        isHost = false;
        document.getElementById('join-game-code').textContent = gameCode;
        document.getElementById('join-info').style.display = 'block';
        connectedPlayers = data.players;
        updatePlayersList();
      });

      socket.on('playerJoined', (data) => {
        connectedPlayers[data.playerId] = data.player;
        updatePlayersList();
      });

      socket.on('playerLeft', (data) => {
        delete connectedPlayers[data.playerId];
        updatePlayersList();
      });

      socket.on('gameStarted', (data) => {
        gameState = data.gameState;
        startMultiplayerGame();
      });

      socket.on('gameStateUpdate', (data) => {
        gameState = data.gameState;
        updateGameFromState();
      });

      socket.on('challengeReceived', (data) => {
        receiveChallenge(data);
      });

      socket.on('startCardRecall', (data) => {
        startCardRecallPhase();
      });

      socket.on('cardRecallResult', (data) => {
        handleCardRecallResult(data);
      });

      socket.on('error', (error) => {
        showGameMessage(error.message);
      });

    function restartGame() {
      if (isHost) {
        socket.emit('gameAction', {
          gameCode,
          action: 'restartGame'
        });
      }
    }
    }

    // Screen navigation
    function showMenuScreen() {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById('menu-screen').classList.add('active');
    }

    function showHostScreen() {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById('host-screen').classList.add('active');
    }

    function showJoinScreen() {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById('join-screen').classList.add('active');
    }

    // Host game functions
    function hostGame() {
      const hostName = document.getElementById('host-name').value.trim() || 'Host Player';
      
      if (!socket) {
        initSocket();
      }
      
      socket.emit('hostGame', { playerName: hostName });
      document.getElementById('host-btn').disabled = true;
    }

    function joinGame() {
      const playerName = document.getElementById('join-name').value.trim() || 'Player';
      const code = document.getElementById('game-code-input').value.trim().toUpperCase();
      
      if (!code) {
        showGameMessage('Please enter a game code');
        return;
      }

      if (!socket) {
        initSocket();
      }
      
      socket.emit('joinGame', { gameCode: code, playerName: playerName });
      document.getElementById('join-btn').disabled = true;
    }

    function startHostedGame() {
      if (Object.keys(connectedPlayers).length < 3) {
        showGameMessage('Need at least 3 players to start');
        return;
      }
      
      socket.emit('startGame', { gameCode });
    }

    // Update functions
    function updateConnectionStatus(connected) {
      const status = document.getElementById('connection-status');
      if (status) {
        status.textContent = connected ? 'Connected' : 'Disconnected';
        status.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
      }
    }

    function updatePlayersList() {
      const hostList = document.getElementById('host-players-list');
      const joinList = document.getElementById('join-players-list');
      
      const playerCount = Object.keys(connectedPlayers).length;
      
      // Update start button state
      const startBtn = document.getElementById('start-game-btn');
      if (startBtn) {
        const needed = Math.max(0, 3 - playerCount);
        startBtn.disabled = playerCount < 3;
        startBtn.textContent = needed > 0 ? 
          `Start Game (Need ${needed} more player${needed !== 1 ? 's' : ''})` : 
          `Start Game (${playerCount} players)`;
      }

      // Update both lists
      [hostList, joinList].forEach(list => {
        if (list) {
          list.innerHTML = '';
          Object.entries(connectedPlayers).forEach(([id, player]) => {
            const item = document.createElement('div');
            item.className = 'player-item';
            if (player.isHost) item.classList.add('is-host');
            if (id === playerId) item.classList.add('is-you');
            
            item.innerHTML = `
              <span>${player.name} ${player.isHost ? 'üëë' : ''} ${id === playerId ? '(You)' : ''}</span>
              <div class="status-indicator"></div>
            `;
            list.appendChild(item);
          });
        }
      });
    }

    function startMultiplayerGame() {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById('game-screen').classList.add('active');
      
      // Set up game from server state
      playerNames = gameState.playerNames;
      players = gameState.players;
      myPlayerId = playerId;
      
      setupGameTable();
      
      // Show auto-start button only for host
      if (isHost) {
        document.getElementById('auto-start-btn').style.display = 'block';
      }
      
      updateGameStatus('setup');
    }

    function setupGameTable() {
      const table = document.getElementById('table');
      table.innerHTML = '<div id="pyramid" class="pyramid"></div>';

      const radius = 300;
      const centerX = 140;
      const centerY = 180;
      const angleStep = 360 / players.length;

      players.forEach((playerId, i) => {
        const angle = angleStep * i;
        const x = centerX + radius * Math.cos((angle - 90) * Math.PI / 180);
        const y = centerY + radius * Math.sin((angle - 90) * Math.PI / 180);
      
        const player = document.createElement('div');
        player.className = 'player';
        player.id = playerId;
        player.style.left = `${x}px`;
        player.style.top = `${y}px`;
        player.style.transform = 'translate(-50%, -50%)';
        
        if (playerId === myPlayerId) {
          player.classList.add('current-user');
        }
        
        if (connectedPlayers[playerId]?.isHost) {
          player.classList.add('is-host');
        }
        
        playerHands[playerId] = [];
        drinkCounts[playerId] = 0;
        
        const playerHeader = document.createElement('div');
        playerHeader.className = 'player-header';
        
        const nameLabel = document.createElement('div');
        nameLabel.className = 'player-name';
        nameLabel.textContent = playerNames[i];
        
        const drinkCounter = document.createElement('div');
        drinkCounter.className = 'drink-counter';
        drinkCounter.id = `drinks-${playerId}`;
        drinkCounter.textContent = `Drinks: 0`;
        
        playerHeader.appendChild(nameLabel);
        playerHeader.appendChild(drinkCounter);
        
        const playerCards = document.createElement('div');
        playerCards.className = 'player-cards';
        playerCards.id = `cards-${playerId}`;
        
        const playerActions = document.createElement('div');
        playerActions.className = 'player-actions';
        playerActions.id = `actions-${playerId}`;
        playerActions.style.display = 'none';
        
        player.appendChild(playerHeader);
        player.appendChild(playerCards);
        player.appendChild(playerActions);
        
        table.appendChild(player);
      });
    }

    // Game message system
    function showGameMessage(message, duration = 3000) {
      const messageEl = document.getElementById('game-message');
      messageEl.textContent = message;
      messageEl.style.display = 'block';
      
      setTimeout(() => {
        messageEl.style.display = 'none';
      }, duration);
    }

    // Multiplayer game actions
    function autoStart() {
      if (isHost) {
        socket.emit('gameAction', {
          gameCode,
          action: 'autoStart'
        });
      }
    }

    function startMemorizePhase() {
      if (isHost) {
        socket.emit('gameAction', {
          gameCode,
          action: 'startMemorize'
        });
      }
    }

    function nextPyramidCard() {
      if (isHost) {
        socket.emit('gameAction', {
          gameCode,
          action: 'flipPyramidCard'
        });
      }
    }

    function flipPlayerCard(playerId, cardValue) {
      const playerCards = document.querySelectorAll(`#${playerId} .card`);
      const playerHandCards = playerHands[playerId] || [];
      
      // Find and flip the first matching unflipped card
      for (let i = 0; i < playerHandCards.length && i < playerCards.length; i++) {
        if (playerHandCards[i].value === cardValue && !playerCards[i].classList.contains('flipped')) {
          playerCards[i].classList.add('flipped');
          break;
        }
      }
    }

    function startCardRecallPhase() {
      gamePhase = 'recall';
      updateGameStatus('recall');
      
      showGameMessage('Time to recite your cards! Each player must recall their 4 cards in order.', 5000);
      
      // Show card recall input for current player
      if (myPlayerId === players[0]) { // Start with first player
        showCardRecallInput(0);
      }
    }

    function showCardRecallInput(playerIndex) {
      if (playerIndex >= players.length) {
        // All players done, finish game
        socket.emit('gameAction', { gameCode, action: 'finishGame' });
        return;
      }
      
      const currentPlayerId = players[playerIndex];
      const currentPlayerName = playerNames[playerIndex];
      
      if (currentPlayerId === myPlayerId) {
        // My turn to recall
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.display = 'flex';
        modal.innerHTML = `
          <div class="modal-content">
            <h3>${currentPlayerName}, recite your cards!</h3>
            <p>Enter your 4 cards in order (e.g., "A‚ô† 5‚ô• K‚ô¶ 2‚ô£"):</p>
            <input type="text" id="card-recall-input" placeholder="Enter your cards..." style="width: 300px; margin: 10px 0;">
            <div class="modal-buttons">
              <button class="challenge-btn" onclick="submitCardRecall(${playerIndex})">Submit Cards</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        document.getElementById('card-recall-input').focus();
      } else {
        // Show waiting message
        showGameMessage(`${currentPlayerName} is reciting their cards...`, 10000);
      }
    }

    function submitCardRecall(playerIndex) {
      const input = document.getElementById('card-recall-input');
      const recalledCards = input.value.trim();
      
      if (!recalledCards) {
        showGameMessage('Please enter your cards!');
        return;
      }
      
      // Remove the modal
      const modal = document.querySelector('.modal');
      if (modal) modal.remove();
      
      // Send recalled cards to server for verification
      socket.emit('verifyCardRecall', {
        gameCode,
        playerId: myPlayerId,
        playerIndex,
        recalledCards
      });
    }

    // Add socket listener for card recall results
    function handleCardRecallResult(data) {
      if (data.correct) {
        showGameMessage(`${data.playerName} got their cards right!`, 3000);
      } else {
        showGameMessage(`${data.playerName} got it wrong! Finish your drink! üç∫`, 5000);
        // Add penalty drinks
        if (data.playerId === myPlayerId) {
          updateDrinkCount(myPlayerId, 5); // Finish drink = 5 drinks
        }
      }
      
      // Continue to next player after a delay
      setTimeout(() => {
        showCardRecallInput(data.nextPlayerIndex);
      }, 2000);
    }

    function makeSomeoneDrink() {
      if (!gameState.currentPyramidCard) {
        showGameMessage("Wait for a pyramid card to be flipped first!");
        return;
      }
      
      showTargetModal();
    }

    function showTargetModal() {
      const targets = players.filter(p => p !== myPlayerId);
      const modal = document.getElementById('target-modal');
      const messageEl = document.getElementById('target-message');
      const buttonsContainer = document.getElementById('target-buttons');
      
      const myName = playerNames[players.indexOf(myPlayerId)];
      messageEl.textContent = `${myName}, choose who to make drink:`;
      buttonsContainer.innerHTML = '';
      
      targets.forEach(targetId => {
        const targetIndex = players.indexOf(targetId);
        const targetName = playerNames[targetIndex];
        
        const button = document.createElement('button');
        button.className = 'target-player-btn';
        button.textContent = targetName;
        button.onclick = () => {
          selectTarget(targetId);
        };
        
        buttonsContainer.appendChild(button);
      });
      
      const cancelButton = document.createElement('button');
      cancelButton.className = 'cancel-btn';
      cancelButton.textContent = 'Cancel';
      cancelButton.onclick = () => {
        modal.style.display = 'none';
      };
      
      buttonsContainer.appendChild(cancelButton);
      modal.style.display = 'flex';
    }

    function selectTarget(targetId) {
      document.getElementById('target-modal').style.display = 'none';
      
      socket.emit('challenge', {
        gameCode,
        challengerId: myPlayerId,
        targetId: targetId
      });
    }

    function receiveChallenge(data) {
      if (data.targetId === myPlayerId) {
        currentChallenger = data.challengerId;
        currentTarget = data.targetId;
        
        const challengerIndex = players.indexOf(data.challengerId);
        const targetIndex = players.indexOf(data.targetId);
        const challengerName = playerNames[challengerIndex];
        const targetName = playerNames[targetIndex];
        
        document.getElementById('bluff-message').textContent = 
          `${challengerName} wants ${targetName} to drink!`;
        document.getElementById('bluff-modal').style.display = 'flex';
      }
    }

    function acceptDrink() {
      document.getElementById('bluff-modal').style.display = 'none';
      
      socket.emit('challengeResponse', {
        gameCode,
        challengerId: currentChallenger,
        targetId: currentTarget,
        response: 'accept'
      });
      
      currentChallenger = null;
      currentTarget = null;
    }

    function callBluff() {
      document.getElementById('bluff-modal').style.display = 'none';
      
      socket.emit('challengeResponse', {
        gameCode,
        challengerId: currentChallenger,
        targetId: currentTarget,
        response: 'challenge'
      });
      
      currentChallenger = null;
      currentTarget = null;
    }

    function updateGameFromState() {
      // Update game phase and UI
      gamePhase = gameState.phase;
      currentPyramidCard = gameState.currentPyramidCard;
      
      // Update player hands from server state
      if (gameState.playerHands) {
        Object.entries(gameState.playerHands).forEach(([playerId, cards]) => {
          playerHands[playerId] = cards;
          updatePlayerCardsDisplay(playerId, cards);
        });
      }
      
      // Update drink counts
      Object.entries(gameState.drinkCounts || {}).forEach(([playerId, count]) => {
        drinkCounts[playerId] = count;
        const counter = document.getElementById(`drinks-${playerId}`);
        if (counter) {
          counter.textContent = `Drinks: ${count}`;
        }
      });
      
      // Update UI based on phase
      updateGameStatus(gamePhase);
      
      // Update pyramid cards if they exist
      if (gameState.pyramidCards) {
        updatePyramidFromState(gameState.pyramidCards);
      }
      
      // Update current card display
      if (currentPyramidCard) {
        document.getElementById('current-card').textContent = currentPyramidCard;
      }
      
      // Show player actions for current player during pyramid phase
      showPlayerActions(gamePhase === 'pyramid');
    }

    function updatePlayerCardsDisplay(playerId, cards) {
      const playerCards = document.getElementById(`cards-${playerId}`);
      if (!playerCards) return;
      
      playerCards.innerHTML = '';
      cards.forEach(card => {
        const cardEl = createPlayerCard(card, playerId);
        playerCards.appendChild(cardEl);
      });
    }

    function createPlayerCard(card, playerId) {
      const cardContainer = document.createElement('div');
      cardContainer.className = 'card';

      const inner = document.createElement('div');
      inner.className = 'card-inner';

      const front = document.createElement('div');
      front.className = 'card-front';
      front.textContent = `${card.value}${card.suit}`;
      if (card.suit === '‚ô•' || card.suit === '‚ô¶') front.style.color = 'red';

      const back = document.createElement('div');
      back.className = 'card-back';
      back.textContent = 'üÇ†';

      inner.appendChild(front);
      inner.appendChild(back);
      cardContainer.appendChild(inner);

      cardContainer.addEventListener('click', (e) => {
        e.stopPropagation();
        if (gamePhase === 'memorize' && playerId === myPlayerId) {
          cardContainer.classList.toggle('flipped');
        }
      });

      return cardContainer;
    }

    function updatePyramidFromState(pyramidCards) {
      const pyramid = document.getElementById('pyramid');
      if (pyramidCards.length === 0) return;
      
      pyramid.innerHTML = '';
      let cardIndex = 0;
      
      // Rebuild pyramid structure based on player count
      const rows = players.length < 8 ? 6 : Math.max(1, 8 - players.length);
      
      for (let row = 1; row <= rows && cardIndex < pyramidCards.length; row++) {
        const rowEl = document.createElement('div');
        rowEl.className = 'row';
        
        for (let i = 0; i < row && cardIndex < pyramidCards.length; i++) {
          const cardData = pyramidCards[cardIndex];
          const card = createPyramidCard(cardData, cardIndex);
          
          // Flip card if it's been revealed
          if (cardData.revealed) {
            card.classList.add('flipped');
          }
          
          rowEl.appendChild(card);
          cardIndex++;
        }
        pyramid.appendChild(rowEl);
      }
    }

    function createPyramidCard(cardData, index) {
      const cardContainer = document.createElement('div');
      cardContainer.className = 'card';
      cardContainer.dataset.index = index;

      const inner = document.createElement('div');
      inner.className = 'card-inner';

      const front = document.createElement('div');
      front.className = 'card-front';
      front.textContent = `${cardData.value}${cardData.suit}`;
      if (cardData.suit === '‚ô•' || cardData.suit === '‚ô¶') front.style.color = 'red';

      const back = document.createElement('div');
      back.className = 'card-back';
      back.textContent = 'üÇ†';

      inner.appendChild(front);
      inner.appendChild(back);
      cardContainer.appendChild(inner);

      return cardContainer;
    }

    function updateGameStatus(phase) {
      gamePhase = phase;
      const phaseDisplay = document.getElementById('phase-display');
      const timerDisplay = document.getElementById('timer-display');
      const cardDisplay = document.getElementById('current-card-display');
      const currentTurn = document.getElementById('current-turn');
      
      // Hide all buttons first
      document.getElementById('auto-start-btn').style.display = 'none';
      document.getElementById('memorize-btn').style.display = 'none';
      document.getElementById('pyramid-btn').style.display = 'none';
      
      // Remove any existing restart button
      const existingRestartBtn = document.getElementById('restart-btn');
      if (existingRestartBtn) {
        existingRestartBtn.remove();
      }
      
      switch(phase) {
        case 'setup':
          phaseDisplay.textContent = 'Phase: Ready to deal cards';
          timerDisplay.style.display = 'none';
          cardDisplay.style.display = 'none';
          currentTurn.textContent = 'Ready to Start!';
          
          // Show auto-start button only for host
          if (isHost) {
            document.getElementById('auto-start-btn').style.display = 'block';
          }
          break;
          
        case 'dealt':
          phaseDisplay.textContent = 'Phase: Cards dealt - Ready to memorize';
          timerDisplay.style.display = 'none';
          cardDisplay.style.display = 'none';
          currentTurn.textContent = 'Cards Ready!';
          
          // Show memorize button only for host
          if (isHost) {
            document.getElementById('memorize-btn').style.display = 'block';
          }
          break;
          
        case 'memorize':
          phaseDisplay.textContent = 'Phase: MEMORIZE YOUR CARDS!';
          timerDisplay.style.display = 'block';
          cardDisplay.style.display = 'none';
          currentTurn.textContent = 'Everyone Memorize!';
          
          // Start local memorize timer and flip own cards
          startLocalMemorizePhase();
          break;
          
        case 'pyramid':
          phaseDisplay.textContent = 'Phase: Pyramid Game';
          timerDisplay.style.display = 'none';
          cardDisplay.style.display = 'block';
          currentTurn.textContent = 'Playing the Pyramid';
          
          // Show pyramid controls only for host
          if (isHost) {
            document.getElementById('pyramid-btn').style.display = 'block';
          }
          break;
          
        case 'recall':
          phaseDisplay.textContent = 'Phase: Card Recall - Recite Your Cards!';
          timerDisplay.style.display = 'none';
          cardDisplay.style.display = 'none';
          currentTurn.textContent = 'Recall Phase';
          break;
          
        case 'finished':
          phaseDisplay.textContent = 'Phase: Game Complete!';
          timerDisplay.style.display = 'none';
          cardDisplay.style.display = 'none';
          currentTurn.textContent = 'Game Finished!';
          
          // Show restart button only for host (and only once)
          if (isHost && !document.getElementById('restart-btn')) {
            const restartBtn = document.createElement('button');
            restartBtn.id = 'restart-btn';
            restartBtn.textContent = 'Restart Game';
            restartBtn.style.backgroundColor = '#27ae60';
            restartBtn.style.color = 'white';
            restartBtn.style.padding = '8px 12px';
            restartBtn.style.fontSize = '0.8rem';
            restartBtn.style.margin = '2px';
            restartBtn.onclick = () => {
              restartGame();
              restartBtn.remove(); // Remove button after clicking
            };
            
            const phaseActions = document.querySelector('.phase-actions');
            phaseActions.appendChild(restartBtn);
          }
          break;
      }
    }

    function startLocalMemorizePhase() {
      timeLeft = 30;
      
      // Only flip the current user's cards face up
      const myPlayerCards = document.querySelectorAll(`#${myPlayerId} .card`);
      myPlayerCards.forEach(card => {
        card.classList.add('flipped');
      });
      
      memorizeTimer = setInterval(() => {
        timeLeft--;
        document.getElementById('countdown').textContent = timeLeft;
        
        if (timeLeft <= 0) {
          clearInterval(memorizeTimer);
          endLocalMemorizePhase();
        }
      }, 1000);
    }

    function endLocalMemorizePhase() {
      // Flip only the current user's cards back to face down
      const myPlayerCards = document.querySelectorAll(`#${myPlayerId} .card`);
      myPlayerCards.forEach(card => {
        card.classList.remove('flipped');
      });
    }

    function showPlayerActions(show) {
      players.forEach(playerId => {
        const actions = document.getElementById(`actions-${playerId}`);
        if (actions) {
          if (show && playerId === myPlayerId) {
            createPlayerActions(playerId);
            actions.style.display = 'flex';
          } else {
            actions.style.display = 'none';
          }
        }
      });
    }

    function createPlayerActions(playerId) {
      const actionsDiv = document.getElementById(`actions-${playerId}`);
      if (!actionsDiv) return;
      
      actionsDiv.innerHTML = '';
      
      const makePlayerDrinkBtn = document.createElement('button');
      makePlayerDrinkBtn.className = 'action-btn target-btn';
      makePlayerDrinkBtn.textContent = 'Make Someone Drink';
      makePlayerDrinkBtn.onclick = () => makeSomeoneDrink();
      
      actionsDiv.appendChild(makePlayerDrinkBtn);
    }

    function startRecallPhase() {
      if (isHost) {
        socket.emit('gameAction', {
          gameCode,
          action: 'startRecall'
        });
      }
    }

    // Initialize when page loads
    window.addEventListener('load', () => {
      // Auto-connect socket for testing
      // initSocket();
    });

  </script>
</body>
</html>
